<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Photogrammetric Camera</title>
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link rel="shortcut icon" href="https://histovis.s3.eu-west-3.amazonaws.com/icons/histovis.ico">
        <style>
            html { height: 100%; }
            body { margin: 0; overflow: hidden; height: 100%; }
        </style>
    </head>
    <body>
        <script src="../dist/photogrammetric-camera.js"></script>
        <script>
            // Three library
            var THREE = photogrammetricCamera.THREE;
            // Data GUI
            var GUI = photogrammetricCamera.GUI;
        </script>

        </script>
        <script>
            // Three library
            var OrbitControls = photogrammetricCamera.OrbitControls;
            var PLYLoader = photogrammetricCamera.PLYLoader;
            var MapControls = photogrammetricCamera.MapControls;

        </script>
        <script>
            // Files Management
            var FetchSource = photogrammetricCamera.FetchSource;
            var FilesSource = photogrammetricCamera.FilesSource;
            // Parsers
            var MatisOrientationParser = photogrammetricCamera.MatisOrientationParser;
            var MicmacOrientationParser = photogrammetricCamera.MicmacOrientationParser;
            var OPKOrientationParser = photogrammetricCamera.OPKOrientationParser;
            var BundlerOrientationParser = photogrammetricCamera.BundlerOrientationParser;

            // Materials
            var OrientedImageMaterial = photogrammetricCamera.OrientedImageMaterial;
            var NewMaterial = photogrammetricCamera.NewMaterial;
            var ShadowMapMaterial = photogrammetricCamera.ShadowMapMaterial;
            var imageVS = photogrammetricCamera.imageVS;
            var imageFS = photogrammetricCamera.imageFS;
            var viewFS = photogrammetricCamera.viewFS;
            // Photogrammetric camera
            var PhotogrammetricCamera = photogrammetricCamera.PhotogrammetricCamera;
        </script>

        <script src="js/helpers/photogrammetricHelper.js"></script>
        <script>
            /* ------------------------- Main ------------------------ */
            init();
            var gui = initGUI();
            animate();

            /* ----------------------- Functions --------------------- */
            function init() {
                // HTML container for the rendering scene
                var container = document.createElement('div');
                document.body.appendChild(container);

                // Sizes
                width = window.innerWidth;
                height = window.innerHeight;

                // Renderer
                renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(width, height);
                container.appendChild(renderer.domElement);

                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);

                // Cameras 
                cameras = new THREE.Group();
                cameras.visible = false;
                scene.add(viewCamera);
                scene.add(cameras);

                // Materials
                basicMaterial = initBasicMaterial();
                wireMaterial = initWireMaterial();
                [textureMaterialUniforms, textureMaterial] = initTextureMaterial(imageVS, imageFS, uvTexture);
                viewMaterialUniforms = initCameraMaterialUniforms(imageVS, viewFS, uvTexture);

                // newMaterial

                const pointsMaterial = new NewMaterial({
                    map: uvTexture,
                });

                const shadowMapMaterial = new ShadowMapMaterial();

                // Environment
                environment = new THREE.Group();
                backgroundSphere = initBackgroundSphere(textureMaterial);
                worldPlane = initWorldPlane(textureMaterial);

                environment.add(backgroundSphere);
                environment.add(worldPlane);
                environment.visible = false;
                scene.add(environment);

                // Controls
                controls = new MapControls(viewCamera, renderer.domElement);
				controls.enableDamping = false;
				controls.screenSpacePanning = false;
                controls.maxPolarAngle = 0.75*Math.PI;
                controls.enableKeys = false;

                // Event listeners
                window.addEventListener('resize', onWindowResize, false);
                document.addEventListener('keydown', onDocumentKeyDown, false);

                // Available collections
                collections = {
                    Sample: function(){
                        clean();
                        worldPlane.visible = false;
                        var path = 'https://raw.githubusercontent.com/micmacIGN/Documentation/master/FilesSamples/';
                        var source = new FetchSource(path);
                        loadOrientation('Orientation-00.xml', source);
                        loadOrientation('Orientation-1.xml', source);
                        updateEnvironment();
                    },
                    Maurepas: function() {
                        clean();
                        collection = 'collections/maurepas/';
                        loadJSON(textureMaterial, server + collection);
                    },
                    Frejus: function() {
                        clean();
                        backgroundSphere.visible = false;
                        collection = 'collections/frejus_original/';
                        loadJSON(textureMaterial, server + collection);
                    },
                    Viabon: function() {
                        clean();
                        backgroundSphere.visible = false;
                        collection = 'collections/viabon/';
                        loadJSON(textureMaterial, server + collection);
                    },
                    SaintMartin: function() {
                        clean();
                        collection = 'collections/saint_martin/';
                        loadJSON(textureMaterial, server + collection);
                    },
                    Ramses: function() {
                        clean();
                        loadJSON(textureMaterial, 'http://mathieu.bredif.free.fr/cors.php?url=data/ramses/');
                    },
                    Abbey: function() {
                        clean();
                        var path = 'https://raw.githubusercontent.com/micmacIGN/Documentation/master/Data/CompensOnLine/';
                        var source = new FetchSource(path);
                        loadOrientedImage('Ori-Rel/Orientation-Abbey-IMG_0204.jpg.xml', 'Abbey-IMG_0204.jpg', source);
                        loadOrientedImage('Ori-Rel/Orientation-Abbey-IMG_0205.jpg.xml', 'Abbey-IMG_0205.jpg', source);
                        loadOrientedImage('Ori-Rel/Orientation-Abbey-IMG_0206.jpg.xml', 'Abbey-IMG_0206.jpg', source);
                        loadOrientedImage('Ori-Rel/Orientation-Abbey-IMG_0207.jpg.xml', 'Abbey-IMG_0207.jpg', source);
                        // plane.position.z = -16.56;
                        // orbitControls.target.set(0, 0, plane.position.z);
                    },
                    Cuxa: function() {
                        clean();
                        loadJSON(textureMaterial, 'http://mathieu.bredif.free.fr/cors.php?url=data/cuxa/');
                    },
                    Alex: function() {
                        var source = new FetchSource('data/alex/');
                        var sphere = new THREE.Mesh(new THREE.SphereGeometry(-1, 32, 32), textureMaterial);
                        var plane = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000, 100, 100), textureMaterial);


                        const pixel = 0.004; // mm
                        const focal = 123.9/pixel; // mm
                        const size = [26460, 17004];
                        source.cameras = { "UCE-M3-f120" : new PhotogrammetricCamera(focal, size) };

                        const orientations = loadOrientation('20FUALPMAR_alt.OPK', source);
                        sphere.visible = false;

                        orientations.then(cameras => {
                            cameras.map(cam => loadImage(cam.name + '.jpg', source))
                        });
                        orientations.then(cameras => {
                            plane.position.x = cameras[0].position.x;
                            plane.position.y = cameras[0].position.y;
                            plane.position.z = 0;
                            plane.updateMatrixWorld();
                            // orbitControls.target.copy(plane.position);
                        });
                        const scale = 30000;
                        plane.scale.set(scale,scale,scale);

                        const mes = source.open('sample.MES', 'text').then(text => OPKOrientationParser.parseMES(text, 'sample.MES'));
                        const xyz = source.open('sample.XYZ', 'text').then(text => OPKOrientationParser.parseXYZ(text, 'sample.XYZ'));

                        xyz.then(data => {
                            const geometry = new THREE.BufferGeometry();
                            geometry.setAttribute('position', new THREE.BufferAttribute( data.position, 3 ));
                            const material = new THREE.PointsMaterial( { color: 0xff0000, size: 10} );
                            const gcp = new THREE.Points(geometry, material);
                             scene.add(gcp);
                        });

                        Promise.all([xyz, orientations, mes]).then(res => {
                            var [x, o, m] = res;
                            const geometry = new THREE.BufferGeometry();
                            const position = new Float32Array( 3*o.length + x.position.length);
                            position.set(x.position, 3*o.length);
                            const cameraDict = {};
                            for(var c = 0; c < o.length; ++c) {
                                o[c].position.toArray(position, 3*c);
                                cameraDict[o[c].name] = c;
                            }
                            geometry.setAttribute('position', new THREE.BufferAttribute( position, 3 ));

                            const measureDict = {};
                            for(var i = 0; i< x.size; ++i)
                            {
                                measureDict[x.name[i]] = i + o.length;
                            }

                            const indices = [];
                            for(var i = 0; i< m.size; ++i)
                            {
                                const camera = cameraDict[m.image[i]];
                                const measure = measureDict[m.name[i]];
                                indices.push(camera, measure);
                            }
                            geometry.setIndex( indices );
                            geometry.computeBoundingSphere();

                            const material = new THREE.LineBasicMaterial( { color: 0xffff00, linewidth: 1} );
                            const lines = new THREE.LineSegments(geometry, material);
                            scene.add(lines);
                            lines.visible = false;
                        });
                    },
                    NotreDame: function() {
                        var sphere = new THREE.Mesh(new THREE.SphereGeometry(-1, 32, 32), textureMaterial);
                        var plane = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000, 100, 100), textureMaterial);

                        var source = new FetchSource('data/NotreDame/');
                        const list = source.open('list2.txt', 'text');
                        const out  = source.open('notredame_cameras.out', 'text');
                        const orientations = Promise.all([list, out]).then(BundlerOrientationParser.parse).then(cameras => {
                                handleOrientation(cameras);
                                // cameras.map(cam => loadImage('images/rd/'+cam.name + '.rd.jpg', source, cam.name));
                                cameras.map(cam => loadImage('images/'+cam.name + '.jpg', source, cam.name))
                                console.log('cameras', cameras);
                                const geometry = new THREE.BufferGeometry();
                                geometry.setAttribute('position', new THREE.BufferAttribute( cameras.points, 3 ));
                                geometry.setAttribute('color', new THREE.BufferAttribute( cameras.colors, 3, true ));
                                geometry.computeBoundingSphere();
                                const material = textureMaterial; // new THREE.PointsMaterial( { size: 1, sizeAttenuation: false } );
                                const gcp = new THREE.Points(geometry, material);
                                scene.add(gcp);
                            }
                        );
                        plane.visible = false;
                        sphere.visible = false;
                    },
                };

                /* Clean --------------------------------------------- */
                function clean() {
                    basicClean();
                }
            }

            function initGUI() {
                var gui = new GUI();

                // Collections options
                function menuCollections(){
                    for(const key in collections) collectionsGUI.add(collections, key);
                    collectionsGUI.closed = false;
                }

                var collectionsGUI = gui.addFolder('Collections');
                menuCollections();

                // View Camera
                function updateViewCameraFromGUI() {
                    viewCamera.updateProjectionMatrix();
                };

                var viewGUI = gui.addFolder('View Camera'); // View
                viewGUI.visible = viewGUI.add(cameras, 'visible').name('viewpoints');
                viewGUI.zoom = viewGUI.add(viewCamera, 'zoom', 0, 2).onChange(updateViewCameraFromGUI);

                // Texture Camera
                var textureGUI = gui.addFolder('Historical Camera');
                textureGUI.opacity = textureGUI.add(textureMaterial, 'opacity', 0, 1);
                textureGUI.borderSharpness = textureGUI.add(textureMaterial.debug, 'borderSharpness', 2, 1000).name("sharpness");

                // Background 
                var backgroundGUI = gui.addFolder('Background');
                backgroundGUI.diffuseColorGrey = backgroundGUI.add(textureMaterial.debug, 'diffuseColorGrey');
                backgroundGUI.wireframe = backgroundGUI.add(textureMaterial, 'wireframe');
                backgroundGUI.sphere = backgroundGUI.add(backgroundSphere, 'visible').name('sphere visible');
                backgroundGUI.plane = backgroundGUI.add(worldPlane, 'visible').name('plane visible');

                // Update controls functions
                gui.updateFromCameras = function updateFromCameras(viewCamera, textureCamera, environment) {
                    viewGUI.zoom.setValue(viewCamera.zoom);
                    backgroundGUI.sphere.setValue(environment.children[0].visible);
                    backgroundGUI.plane.setValue(environment.children[1].visible);
                    var name = textureCamera.name;
                    if (name.length > 0) {
                        if(name.length > 20) name = name.substr(0,8)+'[..]'+name.substr(-8,8);
                        textureGUI.name = 'Hist: ' + name;
                    }     
                }
                return gui;
            };

            function render() {
                renderer.render(scene, viewCamera);
            }

            function animate(timestamp) {
                requestAnimationFrame(animate);
                interpolateCamera(timestamp);
                updateMaterial(textureMaterial);
                gui.updateFromCameras(viewCamera, textureCamera, environment);
                render();
            }
        </script>
    </body>
</html>